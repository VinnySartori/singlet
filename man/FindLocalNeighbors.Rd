% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FindLocalNeighbors.R
\name{FindLocalNeighbors.Seurat}
\alias{FindLocalNeighbors.Seurat}
\alias{FindLocalNeighbors}
\title{(Shared) Local Nearest-neighbor graph construction}
\usage{
\method{FindLocalNeighbors}{Seurat}(
  object,
  k.param = 20,
  spatial.radius = 4,
  spatial.reduction = "spatial",
  reduction = "nmf",
  nn.metric = "jaccard",
  use.dist = FALSE,
  compute.SNN = TRUE,
  prune.SNN = 1/15,
  prune.KNN = 1/10,
  return.dist = FALSE,
  verbose = FALSE,
  dims = NULL,
  graph.name = NULL,
  threads = 0,
  ...
)

FindLocalNeighbors(object, ...)
}
\arguments{
\item{object}{An object}

\item{k.param}{Defines k for the k-nearest neighbor algorithm}

\item{spatial.reduction}{Spatial coordinates to use as input for building the (S)NN. Ensure that radius is given in the same units as spatial coordinates, and that spatial coordinates are fixed on both axes (not scaled).}

\item{reduction}{Reduction to use as input for building the (S)NN}

\item{nn.metric}{Distance metric for nearest neighbors search. Options include: jaccard, cosine, euclidean, manhattan, hamming, and kl (kullback-leibler divergence).}

\item{use.dist}{use distance instead of similarity (i.e. find k-furthest-neighbors). Useful for edge detection. Applies only to \code{metric = c("jaccard", "cosine")}.}

\item{compute.SNN}{also compute the shared nearest neighbor graph}

\item{prune.SNN}{Sets the cutoff for acceptable Jaccard index when computing the neighborhood overlap for the SNN construction. Any edges with values less than or equal to this will be set to 0 and removed from the SNN graph. Essentially sets the stringency of pruning (0 = no pruning, 1 = prune everything).}

\item{prune.KNN}{Sets the cutoff for acceptable distance when computing the neighborhood for the Local KNN graph construction. Any edges with values less than or equal to this will be set to 0 and removed from the KNN graph.  Essentially sets the stringency of pruning (0 = no pruning, 1 = prune everything when distance is "jaccard" or "cosine", otherwise whatever the equivalent is in the distance specified).}

\item{return.dist}{return distances to nearest neighbors rather than a binary result}

\item{verbose}{print output to the console}

\item{dims}{Dimensions of the reduction to use as input (\code{NULL} = use all dimensions in reduction)}

\item{graph.name}{Naming parameter for stored (S)NN graph. Default is \code{<reduction>_local_(s)nn}. To store both the neighbor graph and the shared nearest neighbor graph, you must supply a vector containing two names to the \code{graph.name} parameter. The first element in the vector will be used to store the nearest neighbor graph, and the second element will be used to store the shared nearest neighbor graph. If only one name is supplied, only the nearest neighbor graph is stored.}

\item{threads}{number of threads to use for parallelization}

\item{...}{not implemented}
}
\value{
an object (Seurat object with graph, or just a graph)
}
\description{
Computes the \code{k.param} nearest neighbors within a spatial radius for a given dataset. Can also optionally (via \code{compute.SNN}), construct a shared nearest neighbor graph by calculating the neighborhood overlap (Jaccard index) between every cell and it's \code{k.param} nearest neighbors. Local KNN calculations are exact.
}
\details{
IMPORTANT: You must make sure that your \code{radius} is given in the same units as your 
\code{spatial.reduction} coordinates, and that your \code{spatial.reduction} gives fixed 
coordinates. This means distance on x-coordinates must be equal to distance on y-coordinates.
 Many spatial assays store distances in x and y scaled between 0 and 1, which is NOT going 
 to work. You must use \code{\link{RescaleSpatial}} to convert back to a fixed coordinate 
 system. If your radius is 5, this function will look for neighbors within a distance of 5 
 from a given point as determined by your spatial coordinates.
}
